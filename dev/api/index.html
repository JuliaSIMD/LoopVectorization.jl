<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API reference · LoopVectorization.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="LoopVectorization.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">LoopVectorization.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../getting_started/">Getting Started</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples/multithreading/">Multithreading</a></li><li><a class="tocitem" href="../examples/matrix_multiplication/">Matrix Multiplication</a></li><li><a class="tocitem" href="../examples/array_interface/">Array Interface</a></li><li><a class="tocitem" href="../examples/matrix_vector_ops/">Matrix-Vector Operations</a></li><li><a class="tocitem" href="../examples/dot_product/">Dot Products</a></li><li><a class="tocitem" href="../examples/datetime_arrays/">Composite Types: DateTime Arrays</a></li><li><a class="tocitem" href="../examples/special_functions/">Special Functions</a></li><li><a class="tocitem" href="../examples/sum_of_squared_error/">Sum of squared error</a></li><li><a class="tocitem" href="../examples/filtering/">Image Filtering</a></li></ul></li><li><a class="tocitem" href="../vectorized_convenience_functions/">Vectorized Convenience Functions</a></li><li><a class="tocitem" href="../future_work/">Future Work</a></li><li class="is-active"><a class="tocitem" href>API reference</a><ul class="internal"><li><a class="tocitem" href="#Macros"><span>Macros</span></a></li><li><a class="tocitem" href="#map-like-constructs"><span><code>map</code>-like constructs</span></a></li><li><a class="tocitem" href="#filter-like-constructs"><span><code>filter</code>-like constructs</span></a></li><li><a class="tocitem" href="#reduce-like-constructs"><span><code>reduce</code>-like constructs</span></a></li></ul></li><li><span class="tocitem">Developer Documentation</span><ul><li><a class="tocitem" href="../devdocs/overview/">Developer Overview</a></li><li><a class="tocitem" href="../devdocs/loopset_structure/">LoopSet Structure</a></li><li><a class="tocitem" href="../devdocs/constructing_loopsets/">Constructing LoopSets</a></li><li><a class="tocitem" href="../devdocs/evaluating_loops/">Determining the strategy for evaluating loops</a></li><li><a class="tocitem" href="../devdocs/lowering/">Lowering</a></li><li><a class="tocitem" href="../devdocs/reference/">Internals reference</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaSIMD/LoopVectorization.jl/blob/main/docs/src/api.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API-reference"><a class="docs-heading-anchor" href="#API-reference">API reference</a><a id="API-reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-reference" title="Permalink"></a></h1><h2 id="Macros"><a class="docs-heading-anchor" href="#Macros">Macros</a><a id="Macros-1"></a><a class="docs-heading-anchor-permalink" href="#Macros" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="LoopVectorization.@turbo" href="#LoopVectorization.@turbo"><code>LoopVectorization.@turbo</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@turbo</code></pre><p>Annotate a <code>for</code> loop, or a set of nested <code>for</code> loops whose bounds are constant across iterations, to optimize the computation. For example:</p><pre><code class="nohighlight hljs">function AmulB!(C, A, B)
    @turbo for m ∈ indices((A,C), 1), n ∈ indices((B,C), 2) # indices((A,C),1) == axes(A,1) == axes(C,1)
        Cₘₙ = zero(eltype(C))
        for k ∈ indices((A,B), (2,1)) # indices((A,B), (2,1)) == axes(A,2) == axes(B,1)
            Cₘₙ += A[m,k] * B[k,n]
        end
        C[m,n] = Cₘₙ
    end
end</code></pre><p>The macro models the set of nested loops, and chooses an ordering of the three loops to minimize predicted computation time.</p><p>Current limitations:</p><ol><li>It assumes that loop iterations are independent.</li><li>It does not perform bounds checks.</li><li>It assumes that each loop iterates at least once. (Use <code>@turbo check_empty=true</code> to lift this assumption.)</li><li>That there is only one loop at each level of the nest.</li></ol><p>It may also apply to broadcasts:</p><pre><code class="language-julia-repl hljs">julia&gt; using LoopVectorization

julia&gt; a = rand(100);

julia&gt; b = @turbo exp.(2 .* a);

julia&gt; c = similar(b);

julia&gt; @turbo @. c = exp(2a);

julia&gt; b ≈ c
true</code></pre><p><strong>Extended help</strong></p><p>Advanced users can customize the implementation of the <code>@turbo</code>-annotated block using keyword arguments:</p><pre><code class="language-julia hljs">@turbo inline = false unroll = 2 thread = 4 body</code></pre><p>where <code>body</code> is the code of the block (e.g., <code>for ... end</code>).</p><p><code>thread</code> is either a Boolean, or an integer. The integer&#39;s value indicates the number of threads to use. It is clamped to be between <code>1</code> and <code>min(Threads.nthreads(),LoopVectorization.num_cores())</code>. <code>false</code> is equivalent to <code>1</code>, and <code>true</code> is equivalent to <code>min(Threads.nthreads(),LoopVectorization.num_cores())</code>.</p><p><code>safe</code> (defaults to <code>true</code>) will cause <code>@turbo</code> to fall back to <code>@inbounds @fastmath</code> if <code>can_turbo</code> returns false for any of the functions called in the loop. You can disable the associated warning with <code>warn_check_args=false</code>.</p><p>Setting the keyword argument <code>warn_check_args=true</code> (e.g. <code>@turbo warn_check_args=true for ...</code>) in a loop or broadcast statement will cause it to warn once if <code>LoopVectorization.check_args</code> fails and the fallback loop is executed instead of the LoopVectorization-optimized loop. Setting it to an integer &gt; 0 will warn that many times, while setting it to a negative integer will warn an unlimited amount of times. The default is <code>warn_check_args = 1</code>. Failure means that there may have been an array with unsupported type, unsupported element types, or (if <code>safe=true</code>) a function for which <code>can_turbo</code> returned <code>false</code>.</p><p><code>inline</code> is a Boolean. When <code>true</code>, <code>body</code> will be directly inlined into the function (via a forced-inlining call to <code>_turbo_!</code>). When <code>false</code>, it wont force inlining of the call to <code>_turbo_!</code> instead, letting Julia&#39;s own inlining engine determine whether the call to <code>_turbo_!</code> should be inlined. (Typically, it won&#39;t.) Sometimes not inlining can lead to substantially worse code generation, and &gt;40% regressions, even in very large problems (2-d convolutions are a case where this has been observed). One can find some circumstances where <code>inline=true</code> is faster, and other circumstances where <code>inline=false</code> is faster, so the best setting may require experimentation. By default, the macro tries to guess. Currently the algorithm is simple: roughly, if there are more than two dynamically sized loops or and no convolutions, it will probably not force inlining. Otherwise, it probably will.</p><p><code>check_empty</code> (default is <code>false</code>) determines whether or not it will check if any of the iterators are empty. If false, you must ensure yourself that they are not empty, else the behavior of the loop is undefined and (like with <code>@inbounds</code>) segmentation faults are likely.</p><p><code>unroll</code> is an integer that specifies the loop unrolling factor, or a tuple <code>(u₁, u₂) = (4, 2)</code> signaling that the generated code should unroll more than one loop. <code>u₁</code> is the unrolling factor for the first unrolled loop and <code>u₂</code> for the next (if present), but it applies to the loop ordering and unrolling that will be chosen by LoopVectorization, <em>not</em> the order in <code>body</code>. <code>uᵢ=0</code> (the default) indicates that LoopVectorization should pick its own value, and <code>uᵢ=-1</code> disables unrolling for the correspond loop.</p><p>The <code>@turbo</code> macro also checks the array arguments using <code>LoopVectorization.check_args</code> to try and determine if they are compatible with the macro. If <code>check_args</code> returns false, a fall back loop annotated with <code>@inbounds</code> and <code>@fastmath</code> is generated. Note that <code>VectorizationBase</code> provides functions such as <code>vadd</code> and <code>vmul</code> that will ignore <code>@fastmath</code>, preserving IEEE semantics both within <code>@turbo</code> and <code>@fastmath</code>. <code>check_args</code> currently returns false for some wrapper types like <code>LinearAlgebra.UpperTriangular</code>, requiring you to use their <code>parent</code>. Triangular loops aren&#39;t yet supported.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSIMD/LoopVectorization.jl/blob/7d75430df8df3b4d233f16feb3ed502757fa1e5c/src/constructors.jl#L308-L402">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LoopVectorization.@tturbo" href="#LoopVectorization.@tturbo"><code>LoopVectorization.@tturbo</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@tturbo</code></pre><p>Equivalent to <code>@turbo</code>, except it adds <code>thread=true</code> as the first keyword argument. Note that later arguments take precendence.</p><p>Meant for convenience, as <code>@tturbo</code> is shorter than <code>@turbo thread=true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSIMD/LoopVectorization.jl/blob/7d75430df8df3b4d233f16feb3ed502757fa1e5c/src/constructors.jl#L406-L413">source</a></section></article><h2 id="map-like-constructs"><a class="docs-heading-anchor" href="#map-like-constructs"><code>map</code>-like constructs</a><a id="map-like-constructs-1"></a><a class="docs-heading-anchor-permalink" href="#map-like-constructs" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="LoopVectorization.vmap" href="#LoopVectorization.vmap"><code>LoopVectorization.vmap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">vmap(f, a::AbstractArray)
vmap(f, a::AbstractArray, b::AbstractArray, ...)</code></pre><p>SIMD-vectorized <code>map</code>, applying <code>f</code> to each element of <code>a</code> (or paired elements of <code>a</code>, <code>b</code>, ...) and returning a new array.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSIMD/LoopVectorization.jl/blob/7d75430df8df3b4d233f16feb3ed502757fa1e5c/src/simdfunctionals/map.jl#L451-L457">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LoopVectorization.vmap!" href="#LoopVectorization.vmap!"><code>LoopVectorization.vmap!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">vmap!(f, destination, a::AbstractArray)
vmap!(f, destination, a::AbstractArray, b::AbstractArray, ...)</code></pre><p>Vectorized-<code>map!</code>, applying <code>f</code> to batches of elements of <code>a</code> (or paired batches of <code>a</code>, <code>b</code>, ...) and storing the result in <code>destination</code>.</p><p>The function <code>f</code> must accept <code>VectorizationBase.AbstractSIMD</code> inputs. Ideally, all this requires is making sure that <code>f</code> is defined to be agnostic with respect to input types, but if the function <code>f</code> contains branches or loops, more work will probably be needed. For example, a function</p><pre><code class="language-julia hljs">f(x) = x &gt; 0 ? log(x) : inv(x)</code></pre><p>can be rewritten into</p><pre><code class="language-julia hljs">using IfElse
f(x) = IfElse.ifelse(x &gt; 0, log(x), inv(x))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSIMD/LoopVectorization.jl/blob/7d75430df8df3b4d233f16feb3ed502757fa1e5c/src/simdfunctionals/map.jl#L316-L337">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LoopVectorization.vmapnt" href="#LoopVectorization.vmapnt"><code>LoopVectorization.vmapnt</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">vmapnt(f, a::AbstractArray)
vmapnt(f, a::AbstractArray, b::AbstractArray, ...)</code></pre><p>A &quot;non-temporal&quot; variant of <a href="#LoopVectorization.vmap"><code>vmap</code></a>. This can improve performance in cases where <code>destination</code> will not be needed soon.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSIMD/LoopVectorization.jl/blob/7d75430df8df3b4d233f16feb3ed502757fa1e5c/src/simdfunctionals/map.jl#L468-L474">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LoopVectorization.vmapnt!" href="#LoopVectorization.vmapnt!"><code>LoopVectorization.vmapnt!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">vmapnt!(::Function, dest, args...)</code></pre><p>This is a vectorized map implementation using nontemporal store operations. This means that the write operations to the destination will not go to the CPU&#39;s cache. If you will not immediately be reading from these values, this can improve performance because the writes won&#39;t pollute your cache. This can especially be the case if your arguments are very long.</p><pre><code class="language-julia hljs">julia&gt; f(x, y) = exp(-0.5abs2(x - y))
using LoopVectorization, BenchmarkTools

julia&gt; @benchmark map!(f, $z, $x, $y)
x = rand(10^8); y = rand(10^8); z = similar(x);

julia&gt; @benchmark vmap!(f, $z, $x, $y)
f (generic function with 1 method)

julia&gt; @benchmark vmapnt!(f, $z, $x, $y)
BenchmarkTools.Trial:
  memory estimate:  0 bytes
  allocs estimate:  0
  --------------
  minimum time:     439.613 ms (0.00% GC)
  median time:      440.729 ms (0.00% GC)
  mean time:        440.695 ms (0.00% GC)
  maximum time:     441.665 ms (0.00% GC)
  --------------
  samples:          12
  evals/sample:     1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSIMD/LoopVectorization.jl/blob/7d75430df8df3b4d233f16feb3ed502757fa1e5c/src/simdfunctionals/map.jl#L376-L405">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LoopVectorization.vmapntt" href="#LoopVectorization.vmapntt"><code>LoopVectorization.vmapntt</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">vmapntt(f, a::AbstractArray)
vmapntt(f, a::AbstractArray, b::AbstractArray, ...)</code></pre><p>A threaded variant of <a href="#LoopVectorization.vmapnt"><code>vmapnt</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSIMD/LoopVectorization.jl/blob/7d75430df8df3b4d233f16feb3ed502757fa1e5c/src/simdfunctionals/map.jl#L477-L482">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LoopVectorization.vmapntt!" href="#LoopVectorization.vmapntt!"><code>LoopVectorization.vmapntt!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">vmapntt!(::Function, dest, args...)</code></pre><p>A threaded variant of <a href="#LoopVectorization.vmapnt!"><code>vmapnt!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSIMD/LoopVectorization.jl/blob/7d75430df8df3b4d233f16feb3ed502757fa1e5c/src/simdfunctionals/map.jl#L418-L422">source</a></section></article><h2 id="filter-like-constructs"><a class="docs-heading-anchor" href="#filter-like-constructs"><code>filter</code>-like constructs</a><a id="filter-like-constructs-1"></a><a class="docs-heading-anchor-permalink" href="#filter-like-constructs" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="LoopVectorization.vfilter" href="#LoopVectorization.vfilter"><code>LoopVectorization.vfilter</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">vfilter(f, a::AbstractArray)</code></pre><p>SIMD-vectorized <code>filter</code>, returning an array containing the elements of <code>a</code> for which <code>f</code> return <code>true</code>.</p><p>This function requires AVX512 to be faster than <code>Base.filter</code>, as it adds compressstore instructions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSIMD/LoopVectorization.jl/blob/7d75430df8df3b4d233f16feb3ed502757fa1e5c/src/simdfunctionals/filter.jl#L56-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LoopVectorization.vfilter!" href="#LoopVectorization.vfilter!"><code>LoopVectorization.vfilter!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">vfilter!(f, a::AbstractArray)</code></pre><p>SIMD-vectorized <code>filter!</code>, removing the element of <code>a</code> for which <code>f</code> is false.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSIMD/LoopVectorization.jl/blob/7d75430df8df3b4d233f16feb3ed502757fa1e5c/src/simdfunctionals/filter.jl#L65-L69">source</a></section></article><h2 id="reduce-like-constructs"><a class="docs-heading-anchor" href="#reduce-like-constructs"><code>reduce</code>-like constructs</a><a id="reduce-like-constructs-1"></a><a class="docs-heading-anchor-permalink" href="#reduce-like-constructs" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="LoopVectorization.vreduce" href="#LoopVectorization.vreduce"><code>LoopVectorization.vreduce</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">vreduce(op, A::DenseArray; [dims::Int])</code></pre><p>Vectorized version of <code>reduce</code>. Reduces the array <code>A</code> using the operator <code>op</code>. At most one dimension may be supplied as kwarg.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSIMD/LoopVectorization.jl/blob/7d75430df8df3b4d233f16feb3ed502757fa1e5c/src/simdfunctionals/mapreduce.jl#L113-L118">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LoopVectorization.vmapreduce" href="#LoopVectorization.vmapreduce"><code>LoopVectorization.vmapreduce</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">vmapreduce(f, op, A::DenseArray...)</code></pre><p>Vectorized version of <code>mapreduce</code>. Applies <code>f</code> to each element of the arrays <code>A</code>, and reduces the result with <code>op</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSIMD/LoopVectorization.jl/blob/7d75430df8df3b4d233f16feb3ed502757fa1e5c/src/simdfunctionals/mapreduce.jl#L52-L56">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../future_work/">« Future Work</a><a class="docs-footer-nextpage" href="../devdocs/overview/">Developer Overview »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Friday 24 February 2023 11:58">Friday 24 February 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
