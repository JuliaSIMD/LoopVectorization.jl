<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Constructing LoopSets · LoopVectorization.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="LoopVectorization.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">LoopVectorization.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../getting_started/">Getting Started</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../examples/multithreading/">Multithreading</a></li><li><a class="tocitem" href="../../examples/matrix_multiplication/">Matrix Multiplication</a></li><li><a class="tocitem" href="../../examples/array_interface/">Array Interface</a></li><li><a class="tocitem" href="../../examples/matrix_vector_ops/">Matrix-Vector Operations</a></li><li><a class="tocitem" href="../../examples/dot_product/">Dot Products</a></li><li><a class="tocitem" href="../../examples/datetime_arrays/">Composite Types: DateTime Arrays</a></li><li><a class="tocitem" href="../../examples/special_functions/">Special Functions</a></li><li><a class="tocitem" href="../../examples/sum_of_squared_error/">Sum of squared error</a></li><li><a class="tocitem" href="../../examples/filtering/">Image Filtering</a></li></ul></li><li><a class="tocitem" href="../../vectorized_convenience_functions/">Vectorized Convenience Functions</a></li><li><a class="tocitem" href="../../future_work/">Future Work</a></li><li><a class="tocitem" href="../../api/">API reference</a></li><li><span class="tocitem">Developer Documentation</span><ul><li><a class="tocitem" href="../overview/">Developer Overview</a></li><li><a class="tocitem" href="../loopset_structure/">LoopSet Structure</a></li><li class="is-active"><a class="tocitem" href>Constructing LoopSets</a><ul class="internal"><li><a class="tocitem" href="#Loop-expressions"><span>Loop expressions</span></a></li><li><a class="tocitem" href="#Broadcasting"><span>Broadcasting</span></a></li></ul></li><li><a class="tocitem" href="../evaluating_loops/">Determining the strategy for evaluating loops</a></li><li><a class="tocitem" href="../lowering/">Lowering</a></li><li><a class="tocitem" href="../reference/">Internals reference</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Developer Documentation</a></li><li class="is-active"><a href>Constructing LoopSets</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Constructing LoopSets</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaSIMD/LoopVectorization.jl/blob/master/docs/src/devdocs/constructing_loopsets.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Constructing-LoopSets"><a class="docs-heading-anchor" href="#Constructing-LoopSets">Constructing LoopSets</a><a id="Constructing-LoopSets-1"></a><a class="docs-heading-anchor-permalink" href="#Constructing-LoopSets" title="Permalink"></a></h1><h2 id="Loop-expressions"><a class="docs-heading-anchor" href="#Loop-expressions">Loop expressions</a><a id="Loop-expressions-1"></a><a class="docs-heading-anchor-permalink" href="#Loop-expressions" title="Permalink"></a></h2><p>When applying <code>@turbo</code> to a loop expression, it creates a <code>LoopSet</code> without awareness to type information, and then <a href="https://github.com/JuliaSIMD/LoopVectorization.jl/blob/master/src/condense_loopset.jl">condenses the information</a> into a summary which is passed as type information to a generated function.</p><pre><code class="language-julia hljs">julia&gt; @macroexpand @turbo for m ∈ 1:M, n ∈ 1:N
           C[m,n] = zero(eltype(B))
           for k ∈ 1:K
               C[m,n] += A[m,k] * B[k,n]
           end
       end
quote
    var&quot;##vptr##_C&quot; = LoopVectorization.stridedpointer(C)
    var&quot;##vptr##_A&quot; = LoopVectorization.stridedpointer(A)
    var&quot;##vptr##_B&quot; = LoopVectorization.stridedpointer(B)
    begin
        $(Expr(:gc_preserve, :(LoopVectorization._turbo_!(Val{(0, 0)}(), Tuple{:numericconstant, Symbol(&quot;##zero#270&quot;), LoopVectorization.OperationStruct(0x0000000000000012, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, LoopVectorization.constant, 0x00, 0x01), :LoopVectorization, :setindex!, LoopVectorization.OperationStruct(0x0000000000000012, 0x0000000000000000, 0x0000000000000000, 0x0000000000000007, LoopVectorization.memstore, 0x01, 0x02), :LoopVectorization, :getindex, LoopVectorization.OperationStruct(0x0000000000000013, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, LoopVectorization.memload, 0x02, 0x03), :LoopVectorization, :getindex, LoopVectorization.OperationStruct(0x0000000000000032, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, LoopVectorization.memload, 0x03, 0x04), :numericconstant, Symbol(&quot;##reductzero#274&quot;), LoopVectorization.OperationStruct(0x0000000000000012, 0x0000000000000000, 0x0000000000000003, 0x0000000000000000, LoopVectorization.constant, 0x00, 0x05), :LoopVectorization, :vfmadd_fast, LoopVectorization.OperationStruct(0x0000000000000132, 0x0000000000000003, 0x0000000000000000, 0x0000000000030405, LoopVectorization.compute, 0x00, 0x05), :LoopVectorization, :reduce_to_add, LoopVectorization.OperationStruct(0x0000000000000012, 0x0000000000000003, 0x0000000000000000, 0x0000000000000601, LoopVectorization.compute, 0x00, 0x01)}, Tuple{LoopVectorization.ArrayRefStruct(0x0000000000000101, 0x0000000000000102, 0xffffffffffffe03b), LoopVectorization.ArrayRefStruct(0x0000000000000101, 0x0000000000000103, 0xffffffffffffffd6), LoopVectorization.ArrayRefStruct(0x0000000000000101, 0x0000000000000302, 0xffffffffffffe056), LoopVectorization.ArrayRefStruct(0x0000000000000101, 0x0000000000000102, 0xffffffffffffffd6)}, Tuple{0, Tuple{}, Tuple{}, Tuple{}, Tuple{}, Tuple{(1, LoopVectorization.IntOrFloat), (5, LoopVectorization.IntOrFloat)}, Tuple{}}, (LoopVectorization.StaticLowerUnitRange{0}(M), LoopVectorization.StaticLowerUnitRange{0}(N), LoopVectorization.StaticLowerUnitRange{0}(K)), var&quot;##vptr##_C&quot;, var&quot;##vptr##_A&quot;, var&quot;##vptr##_B&quot;, var&quot;##vptr##_C&quot;)), :C, :A, :B))
    end
end</code></pre><p>When the corresponding method gets compiled for specific type of <code>A</code>, <code>B</code>, and <code>C</code>, the call to the <code>@generated</code> function <code>_turbo_!</code> get compiled. This causes the summary to be <a href="https://github.com/JuliaSIMD/LoopVectorization.jl/blob/master/src/reconstruct_loopset.jl">reconstructed</a> using the available type information. This type information can be used, for example, to realize an array has been transposed, and thus correctly identify which axis contains contiguous elements that are efficient to load from. This kind of information cannot be extracted from the raw expression, which is why these decisions are made when the method gets compiled for specific types via the <code>@generated</code> function <code>_turbo_!</code>.</p><p>The three chief components of the summaries are the definitions of operations, e.g.:</p><pre><code class="language-julia hljs">:LoopVectorization, :getindex, LoopVectorization.OperationStruct(0x0000000000000013, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, LoopVectorization.memload, 0x02, 0x03)</code></pre><p>the referenced array objects:</p><pre><code class="language-julia hljs">LoopVectorization.ArrayRefStruct(0x0000000000000101, 0x0000000000000102, 0xffffffffffffe03b)</code></pre><p>and the set of loop bounds:</p><pre><code class="language-julia hljs">(LoopVectorization.StaticLowerUnitRange{0}(M), LoopVectorization.StaticLowerUnitRange{0}(N), LoopVectorization.StaticLowerUnitRange{0}(K))</code></pre><h2 id="Broadcasting"><a class="docs-heading-anchor" href="#Broadcasting">Broadcasting</a><a id="Broadcasting-1"></a><a class="docs-heading-anchor-permalink" href="#Broadcasting" title="Permalink"></a></h2><p>When applying the <code>@turbo</code> macro to a broadcast expression, there are no explicit loops, and even the dimensionality of the operation is unknown.  Consequently the <code>LoopSet</code> object must be constructed at compile time. The function and involved operations are their relationships are straightforward to infer from the structure of nested broadcasts:</p><pre><code class="language-julia hljs">julia&gt; Meta.@lower @. f(g(a,b) + c) / d
:($(Expr(:thunk, CodeInfo(
    @ none within `top-level scope&#39;
1 ─ %1 = Base.broadcasted(g, a, b)
│   %2 = Base.broadcasted(+, %1, c)
│   %3 = Base.broadcasted(f, %2)
│   %4 = Base.broadcasted(/, %3, d)
│   %5 = Base.materialize(%4)
└──      return %5
))))

julia&gt; @macroexpand @turbo @. f(g(a,b) + c) / d
quote
    var&quot;##262&quot; = Base.broadcasted(g, a, b)
    var&quot;##263&quot; = Base.broadcasted(+, var&quot;##262&quot;, c)
    var&quot;##264&quot; = Base.broadcasted(f, var&quot;##263&quot;)
    var&quot;##265&quot; = Base.broadcasted(/, var&quot;##264&quot;, d)
    var&quot;##266&quot; = LoopVectorization.vmaterialize(var&quot;##265&quot;, Val{:Main}())
end</code></pre><p>These nested broadcasted objects already express information very similar to what the <code>LoopSet</code> objects hold. The dimensionality of the objects provides the information on the associated loop dependencies, but again this information is available only when the method is compiled for specific types. The <code>@generated</code> function <code>vmaterialize</code> constructs the LoopSet by recursively evaluating <a href="https://github.com/JuliaSIMD/LoopVectorization.jl/blob/master/src/broadcast.jl#L166">add_broadcast!</a> on all the fields.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../loopset_structure/">« LoopSet Structure</a><a class="docs-footer-nextpage" href="../evaluating_loops/">Determining the strategy for evaluating loops »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.19 on <span class="colophon-date" title="Friday 24 June 2022 15:52">Friday 24 June 2022</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
